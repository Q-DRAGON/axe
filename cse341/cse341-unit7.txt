Unit 7 Ruby，面向对象编程，子类化

123. Ruby 介绍
Ruby 的一些特性：
    Ruby 是一种纯面向对象的语言，这意味着语言中的所有值都是对象。在 Ruby 中，每个表达式都计算为一个对象。
    Ruby 是基于类的:每个对象都是类的实例。并不是所有的面向对象语言都是这样基于类的，例如 JavaScript。
    Ruby 有 mixin，后续详细介绍。
    Ruby 是动态类型的。
    Ruby 有许多动态特性。
    Ruby 具有方便的反射：各种内置方法使得在运行时更容易发现对象的属性。
    Ruby 有块和闭包：块几乎和闭包一样，在 Ruby 库中使用高阶编程更方便。
    Ruby 是一种脚本语言：对于什么是脚本语言并没有精确的定义。脚本语言指这种语言可以方便地写短小的程序，提供控制文件和字符串的方法，而且不用关心性能。
    Ruby 在 web 应用程序中很流行：Ruby on Rails 框架是开发现代 web 站点的服务器端的流行选择。

124. 基于类的面向对象
Ruby 中的一切都是用面向对象的方式描述的：
    所有的值(通常是计算表达式的结果)都是对对象的引用。
    给定一个对象，代码通过调用它的方法“与它通信”。
    每个对象都有自己的私有状态。只有对象的方法才能直接访问或更新它
状态。
    每个对象都是类的实例。
    对象的类决定对象的行为。

125. 对象、类、方法、变量等
class Foo
    def m1
    ...
    end

    def m2 (x,y)
    ...
    end

    ...

    def mn z
    ...
    end
end
如果一个方法参数有一个默认值，那么它右边的所有参数都必须也有一个默认值。
def myMethod (x,y,z=0,w="hi")
    ...
end
调用方法：
    e0.m(e1, ..., en)
    要在与当前正在执行的方法相同的对象上调用另一个方法，可以编写 self.m(…) 或者只是 m(…)。
消息发送（把 e1 的结果当做参数传递，把 e0 当做接收消息的对象）：
    e0.m e1
实例变量：
    Ruby 的类定义没有指明类的实例将会有哪些变量。
    用 @foo 的写法，如果不存在则创建。
    实例变量是对象的私有变量。
    Ruby 也有类变量(类似于Java的静态字段)。它们是 @@foo。类变量不是对象的私有对象。相反，它们由类的所有实例共享，但仍然不是直接共享的可以从不同类的对象访问。
构造一个对象：
    Foo.new (...)
    Ruby 中，不同的实例可以有不同的实例变量。
表达式和局部变量：
    Ruby 中的大多数表达式实际上是方法调用。
    与实例变量一样，方法的局部变量不需要声明：第一次在一个方法中分配 x 时才创建它。变量的作用域是整个方法体。
类常量和类方法：
    类常量：@@，不能改变，公开可见。在类 C 外面，可以通过 C::Foo 读到类的常量。
    类方法：类方法就像一个普通的方法，除了
        （1）它不能读到任何实例的变量或实例的方法，
        （2）你可以在它被定义的 class C 外面读到它，用法是 C.method_name args。
        最通用的建立类方法的是：
        def self.method_name args
            ...
        end

126. 可见性和 getter / setter
请注意，即使相同类的其他实例也无法访问这个实例的变量。这是非常面向对象的，你只能通过发送消息与另一个对象交互。
方法具有不同的可见性。
    默认为 public，这意味着任何对象都可以调用该方法。
    还有 private，与实例变量一样，它只允许对象本身调用方法(从对象中的其他方法调用)。
    介于两者之间的是受保护的：受保护的方法可以由相同类的实例或类的任何子类的任何对象调用。
    定义方法：
        最简单的方法可能是在类定义中，可以在方法定义之间放置 public、 private 或 protected。
        阅读自顶向下，指定的最近可见性对所有方法都有效，直到指定下一个可见性为止。
        在类中的第一个方法之前有一个隐式的public。
为了使实例变量的内容可用和/或可变，我们可以很容易地定义 getter 和 setter 方法。
按照惯例，我们可以给它们取与实例变量相同的名称。
def foo
    @foo
end

def foo= x
  @foo = x
end
或
def foo = x
  @foo = x
end
另一种通用写法：
attr_reader :y, :z # defines getters
attr_accessor :x # defines getters and setters
最后：
如果方法 m 是私有的，您只能调用时写 m 或 m(args)。不能写 x.m 或 self.m。

127. 一些需要熟悉的语法、语义和范围
条件语句可以操作任何对象，并将每个对象视为 “true”，只有两个例外: false 和 nil。
变量(局部变量、实例变量或类变量)是通过赋值自动创建的。

128. 所有东西都是对象
所有对象都有一个 nil? 方法。
当表达式生成的结果没意义的时候，是个 nil。
方法返回 self 通常很方便，这样对同一个对象的后续方法调用就可以放在一起。例如，如果 foo 方法返回 self，那么你可以写 x.foo(14).bar(“hi”)。
有许多方法可以支持反射——在程序执行过程中了解对象及其定义——这个方法是所有对象都有的。如 methods 和 class 方法。
顶层表达式：
    可以在类的定义外面定义方法、变量等。这些方法是隐式添加到类里的。这些方法可以被类里的方法使用。
    程序运行之后顶级表达式是按顺序计算的，所以 Ruby 不用明确定义一个 main 类，或有特殊名字的类，可以直接创建一个对象并且在顶层调用它的方法。

129. 类定义是动态的
Ruby 程序(或 REPL 的用户)可以在 Ruby 程序运行时更改类定义。这自然会影响类的所有用户。
这通常是不可靠的风格，因为它打破了抽象，但它导致了更简单的语言定义：定义类和更改它们的定义只是一个运行时操作，与其他操作一样。但也会破坏程序。
添加或更改方法的语法特别简单：只需给出一个类定义，包括已经定义的类的方法定义。方法定义可以替换以前定义的方法的定义(使用相同的方法名)，也可以添加到类中(如果之前没有名称的方法)。

130. Duck Typing
在 Ruby 中，这指的是传递给方法的对象的类(例如，“Duck”)并不重要，只要对象能够响应预期的所有消息(例如，“walk to x” 或 “quack now”)。
鸭子类型可以使代码更加可重用，允许客户端制作“假鸭子”，并且仍然使用你的代码。
Duck Typing 的缺点，略。

131. 数组
创建：
[e1,e2,e3,4]
Array.new(x) 长度为 x，每个元素都是 nil
Array.new(x) { 0 } 长度为 x，每个元素都是 0
读取：
a[i]
赋值：
a[i] = e
Ruby 的数组没有边界错误。可以自动延长，中间的元素默认是 nil。

132. 块（Blocks）
虽然 Ruby 有 While 循环和 for 循环，但大多数 Ruby 代码并不使用它们。相反，许多类都有使用块的方法。
这些块几乎就是闭包。
例如 times 方法接受一个块：
x.times { puts "hi" }
块是闭包，因为它们可以引用定义块的作用域中的变量，如以下 y 的结果是 10。
y=7
[4,6,8].each { y += 1 }
也可以将数组的元素依次传给块：
sum = 0
[4,6,8].each { |x|
    sum += x
    puts sum
}
令人惊讶的是，块不是对象，不能像一般参数一样被传给方法。
但是任何方法都可以被传递一个或零个块，和其它参数区分开。
sum = [4,6,8].inject(0) { |acc,elt| acc + elt }
可以用 do 语句代替括号。
当用块调用一个方法时，需要知道这个块需要几个参数。没有参数的时候只用删掉 |...| 这部分即可。

133. 使用块
虽然块的许多用法涉及到在标准库中调用方法，但是您也可以定义自己的方法来获取块。(大型标准库使得很少需要这样做。)
您可以将一个块传递给任何方法。方法主体使用 yield 关键字调用块。
def foo x
    if x
        yield
    else
        yield
        yield
    end
end
foo true { puts "hi" }
foo false { puts "hi" }

134. Proc 类
块不是闭包，因为它们不是对象。
我们不能将它们存储在字段中，不能将它们作为常规方法参数传递，不能将它们分配给变量，不能将它们放在数组中，等等。
因此，我们说块不是“一级值”，因为一级值是可以像语言中的其他任何东西一样传递和存储的东西。
而 Proc 类是真正的“闭包”。

135. Hashes 和 Ranges
哈希类和范围类是两个标准库类。
哈希类：
    哈希就像一个数组，只不过映射不是从数值索引到对象。相反，映射是从(任何)对象到对象。
    如果 a 映射到 b，我们称 a 为键，b 为值。
    {"SML" => 7, "Racket" => 12, "Ruby" => 42}
    或
    {:sml => 7, :racket => 12, :ruby => 42}
    使用
    h1["a"] = "Found A"
    h1[false] = "Found false"
    h1["a"]
    h1[false]
    h1[42]
Range 类：
    连续的数字序列。
    1..100 表示 1 到 100 的序列。
    由于 duck typing，用列表的很多时候可以用序列。

136-138. 子类和继承 / 子类的优势 / 覆盖与动态调度
略

139. 方法查找的精确定义
当一个方法被调用时，self 在环境中被绑定到什么。正确的定义是我们所说的动态调度。
答案取决于与 self 绑定的对象，而 self 是被特殊对待的。
在任何环境中，self 都映射到某个对象，我们将其视为“当前对象”——当前执行方法的对象。
mixins 方法。

140. 动态调度与闭包
闭包：使用的是定义时的环境，后面修改不会有影响。
动态调度可以进行改变，但缺点是看到一个类也无法确定它所有的表现。通常情况下，使用不能被重写以避免问题的私有方法会更好。
覆盖和动态调度是区分面向对象编程和函数式编程的最大区别。

141. 在 Racket 中手动实现动态调度
略
