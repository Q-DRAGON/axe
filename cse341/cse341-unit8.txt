Unit 8 程序分解，混合类，子类型等

142. OOP 与函数分解
通过完成一个小型表达式语言的例子，对比 OOP 和函数式编程。这两种哪个更好，主要依赖于个人喜好，以及软件将如何变化或扩展。
基本设置：
    用于小型“语言”的表达式，例如用于算术
    表达式的不同变体，如整数值、否定表达式和加法表达式
    对表达式进行不同的操作，例如求值、将其转换为字符串，或确定表达式中是否包含常数 0
    概念矩阵：
                       eval   toString   hasZero
                Int
                Add
                Negate
函数式编程的方法：
    为表达式定义数据类型，每个变量有一个构造函数。
    为每个操作定义一个函数。
    在每个函数中，对每个变量都有一个分支(例如，通过模式匹配)。
    最后在矩阵中，针对每个列都有一个函数。
面向对象的方法：
    为表达式定义一个类，每个操作使用一个抽象方法。
    为每个数据变体定义一个子类。在每个子类中，为每个操作定义一个方法定义，可以通过继承避免枚举。
    这种方法是面向数据的分解: 将问题分解为相应的类对每个数据变体，即矩阵中每一行是一个类。
哪个更好：
    对于我们的表达式问题，函数方法可能是更受欢迎。
    对于实现图形用户界面之类的问题，可能采用面向对象的方法更受欢迎。
    选择还取决于编程的内容、正在使用的语言、如何组织有用的库等等。

143. 通过添加新的表达式或变量扩展代码
对于函数式编程，添加新操作很容易，但添加一个新的数据变体并不方便。
面向对象的方法正好相反。
规划可扩展性：
    对面向对象，“访问者模式”是一种常见的编程方法。这种模式经常使用双重调度来完成。
    对于函数式编程，我们可以定义数据类型具有“其他”可能性，我们的操作可以接受一个可以处理“其他”的数据。

144. 带有函数分解的二元方法
如果函数有多个参数，会变得更复杂一些，如：
    如果参数是整数或有理，做适当的算术。
    如果任何一个参数都是字符串，将另一个参数转换为字符串(除非它已经是字符串)返回字符串的连接。
    我们可以把多种情况的分解抽出来单独写一个辅助函数。

145. OOP 中的二元方法:双重调度
针对一个数据类型类里的每个方法，进行对参数的类型判断和相应的操作定义。虽然这种方法有效，但它实际上不是面向对象编程。相反，它是面向对象分解(第一个参数的动态分派)和功能分解(使用is_a?找出每个方法中的案例)。
更 OOP 的方法是，把需要知道参数 v 的类型变成调用一个 v 自己的方法，在调用方法时把 v 自己的类型传进去。这个技术叫做双重分发。

146. 多重方法
比双重分发更方便的方法是多重方法。每个数据类型都有一个 add_values 方法，表示出来它期待的参数的类型。调用 e1.eval.add_values e2.eval 时，就能选出正确的方法。运行时，会考虑 e1.eval 和 e2.eval 的类。
之前我们考虑的更多的是我们所调用方法的那个类的类型，多重分派是“更动态的分派”，它考虑到多种对象的类，并使用所有这些信息来选择调用什么方法。
Ruby 不支持这种方法，因为 Ruby 一个类里面某个名字只能有一个方法，所以不可能有 3 个 add_values 方法在同一个类中，无法根据参数指示应该使用哪个方法。
Java 和 c++ 也没有多重方法，因为它使用的是参数的类型，这些类型是在编译时确定的，而不是运行的时候。这种语义称为静态重载，不能支持多重分配。
c# 在 4.0 版本支持了。

147. 多重继承
但是，如果继承是如此有用和重要，为什么不允许使用在其他地方(比如另一个类)定义更多代码呢？
    多重继承: 具有多重继承的语言允许一个类扩展自多个其他类。
    Mixins: Ruby 允许一个类有一个直接的超类，但是可以有任意数量的 Mixins。因为 mixin “只是一堆方法”，许多语义问题就会消失。
    Java / c# 风格的接口：Java / c# 类有一个直接的超类，但是可以“实现”任意数量的接口。由于接口不提供行为——它们只需要存在某些方法——大多数语义问题就会消失。
对于多个超类，我们可能会对继承自不同类的字段 / 方法产生冲突。具有多重继承的语言(最著名的是c++)需要相当复杂的规则来解释子类化、方法查找和字段访问的工作方式。

148. 混合类（Mixins）
Ruby 有 mixin，介于多重继承(见上)和接口(见下)之间。它们为包含它们的类提供了实际的代码，但是它们本身并不是类，所以不能创建它们的实例。
module Color
    attr_accessor :color
    def darken
        self.color = "dark " + self.color
    end
end
这个 mixin 定义了三个方法，color, color=, 和 darken。
类在使用时：
class ColorPt < Pt
    include Color
end
找方法的时候，先找类里的，再找 mixin 里的。再找父类的，以此类推。
Ruby 里常用的两个 mixin 是 Enumerable 和 Comparable，可以直接引入使用。

149. Java/C# 的接口
接口并不会真的定义方法，它们只是声明它们并写明它们的数据类型。
动态语言并不需要接口。
实现接口不继承代码，它纯粹与静态类型语言(如 Java 和 c#)中的类型检查有关。

150. 抽象方法
有的类会调用其它方法，而这些方法并没有在自己的类里面被定义。使用这样的类是为了写它们的子类，子类中会基于动态分发定义缺失的方法。这在 Ruby 中很好用，你可以在注释中写明这个类只是为了被写子类。
在静态语言中，这种类被称为抽象类。我们还需要提供(非抽象)子类必须提供的任何方法的类型，这些就是抽象方法。在类型检验中，只有对象的类完成了所有的抽象方法，才能调用这些方法。
具有抽象方法和多重继承(例如 c++)的语言不需要接口。相反，我们可以只使用那些只有抽象(纯虚拟)方法的类，就像它们是接口一样，并且让实现这些“接口”的类只是类的子类。

151. 子类型
之前研究过 ML 的静态类型。ML 类型系统中表达能力的一个关键来源是参数多态性，也称为泛型。
因此，我们还应该研究面向对象程序的静态类型。我们希望类型系统能避免“方法丢失”的错误。

152. 一种虚构的记录语言
为了研究子类型背后的基本思想，我们将使用具有可变字段的记录以及函数和其他表达式。我们的语法将是 ML 和 Java 的混合，这样可以使示例更简短，希望更清晰。
规则略。

153. 深度子类化
让具有一种类型的表达式称为具有较少信息的另一种类型，这是子类型的思想。
对于子类型，关键的指导原则是可替代性：如果我们允许 t1 <: t2，那么类型 t1 的任何值都必须能够以 t2 可以的任何方式使用。这意味着 t1 应该具有 t2 具有的所有字段，并且具有相同的类型。
例子略。

154. Java / c# 数组子类型的问题
略

155. 函数子类型
“函数子类型”决定了一个函数类型是另一个函数类型的子类型。
传递一个返回类型“承诺”更多的函数是安全的。

156. OOP 的子类
我们现在可以将对子类型的理解应用到 OOP 语言中。一个对象本质上是一个有属性和方法的记录。一个完整的子类是类似一个记录或函数的子类的：
    子类可以有额外的属性。
    子类不能有不同的属性类型。
    子类可以有额外的方法。
    子类的方法可以有逆变的参数类型和协变的结果类型。
类和类型是不同的东西。为了方便起见，Java 和 c# 故意混淆了它们。在语言中，每一个类声明都引入一个同名的类和类型。

157. 范型和子类
泛型对什么有好处？
    有些函数组合了其他函数。
        val compose : (’b -> ’c) * (’a -> ’b) -> (’a -> ’c)
    有的函数在集合/容器上运行，不同的集合/容器可以容纳不同类型的值。
        val length : ’a list -> int
        val map : (’a -> ’b) -> ’a list -> ’b list
        val swap : (’a * ’b) -> (’b * ’a)
    在所有这些情况下，关键的一点是，如果我们必须为这些函数选择非泛型类型，那么最终代码重用就会大大减少。泛型类型比仅仅说某个参数可以是“任何东西”更有用、更精确。
子类型不能很好地替代泛型。
子类适合什么？
    它允许使用具有“额外信息”的数据重用代码。
    一个普遍认可的子类型工作良好的例子是图形用户界面。图形库的大部分代码都适用于任何类型的图形元素(“在屏幕上绘制”、“更改背景颜色”、“单击鼠标时报告”等等)，在这些元素中，不同的元素(如按钮、滑块或文本框)可以是子类型。
泛型不能很好地替代子类型。

158. 有边界的多态
举了个例子，略。
