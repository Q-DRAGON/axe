本课程通过对 ML, Racket 和 Ruby 三门语言的学习，讲解任何一门语言是如何“组装在一起的”，
让你更有效地编程，并且能更快地学习一门新语言。

Unit 1 机器语言的函数, Tuple, List 等

3. 机器语言变量赋值和表达式
ML 程序是一系列绑定（binding)。每一次绑定都进行类型检查和数值计算。
    这个绑定是什么类型的，依赖于静态环境（粗略的说，是文件中先前进行的绑定的类型）。
    绑定的数值计算，依赖于动态环境（粗略的说，是文件中先前进行的绑定的数值）。
    我们一般说的环境（environment)，指动态环境，而 context 是静态环境。

4. 表达式规则
变量绑定的语法：
    val x = e;
列举了几种表达式的定义，包括语法、类型检查和数值计算。
当学习一个新的结构时，也应该了解其语法、类型检查规则、数值计算规则。

5. REPL 和报错
在 REPL 中引入文件：
    use "foo.sml";
    类型是 unit ，值是 ()，效果是引入了文件中所有绑定。

6. 覆盖（shadowing)
ML 中，绑定是不可改变的。
    val x = 8+9;
    val x = 19;
    第二句创建了一个新的不同的环境，在新环境中第二次 x 的绑定覆盖（shadow）了第一个。

7.8. 函数
函数绑定示例：
    fun pow (x:int, y:int) = (* correct only for y >= 0 *)
        if y=0
        then 1
        else x * pow(x,y-1)
函数绑定语法：
    fun x0 (x1 : t1, ..., xn : tn) = e
    类型 t 可以省略。
    x0 和它的类型被加到了静态环境中。
    参数并没有被添加到顶层静态环境中，只能在函数体内被使用。
    x0 也在函数体内的动态环境中，可以继续被调用。
函数调用：
    val ans = cube(4)
    当只有一个参数时，括号可以省略。
    函数参数所存在的环境，是函数被定义时的环境，而非被调用时的环境。

9. Pair 和 Tuple
pair:
    (e1,e2)
    类型是 t1*t2
    取 pair 的值：#1 e 或 #2 e
示例：
    fun sort_pair (pr : int*int) =
        if (#1 pr) < (#2 pr)
        then pr
        else ((#2 pr),(#1 pr))
tuple：
    (7,9,11)
    可以有多个数据个数。
    取值：#1 e, #2 e, 和 #3 e

10. Lists
长度无限，但每个数据类型都要相同。
语法：
    [v1,v2,...,vn]
在 list 起始添加一个元素：
    e1 :: e2

11. List 函数
null xs:
    判断是否为空
hd xs:
    返回第一个元素
tl xs:
    返回最后一个元素

12. Let 表达式
创建本地绑定。
语法：
    let b1 b2 ... bn in e end

13. 嵌套函数
示例：
    let val x = 1 in
       (let val x = 2 in x+1 end) + (let val y = x+2 in y+1 end)
    end
    结果为 7。

14. let 的效率
本地变量使程序更可读，免去递归计算的大量计算。

15. Option
如果只有 0 个或者 1 个元素，使用 type option。
isSome e
返回 False，如果 e 是 None。
SOME e
计算 e 的值并让 option 为这个值。
valOf e
返回值，如果是 none 则报错。

16. 其它表达式和运算符
andalso
orelse
not
e1 <> e2   即 e1 != e2
~ e

17. 变量不可变的好处
在一个新环境中，可以覆盖原来的 x 的值，但是当代码寻找之前的那个 x 的时候，它还是原来的值。
是函数式编程的基础，因为别人无法改变你的变量。
让共享数据和化名数据不相关。（改变了化名数据/共享数据其中之一，不用担心另一个是否会跟着改变。）

18. Java 可变的反例
略
