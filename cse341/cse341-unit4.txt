Unit 4 ML 模块，类型推断，等价

65. 单元介绍
之前学过了模式匹配、高阶函数、闭包。
本章学习：
类型推断
相互递归
模块系统
等价

66. 用模块管理命名空间
首先介绍如何使用 ML 模块将绑定分离到不同的名称空间。
再讨论使用模块隐藏绑定和类型。
structure Name = struct bindings end
在这个结构中，可以使用更早的绑定。在结构外，使用 Name.b 访问绑定。
在 ML 中，模块不是表达式，所以不能再函数中定义它们，不能在 tuple 中存储它们，也不能像参数一样传递它们。
在 ML 中，写 open SomeLongStructureName，可以直接访问模块里的绑定，而不需要点语法。
只有写测试时可以用 open，否则会引起同名变量的覆盖。

67. 签名和隐藏东西
签名：
    以上，模块只是用来管理了命名空间，防止同名变量覆盖。
    以下，讲给结构赋予签名，签名相当于是模块的类型。签名提供了模块外的代码必须遵守的严格接口。
    举例（ MyMathLib 必须具有签名 MATHLIB ）：
    signature MATHLIB =
    sig
    val fact : int -> int
    val half_pi : real
    val doubler : int -> int
    end
    structure MyMathLib :> MATHLIB =
    struct
    fun fact x =
        if x=0
        then 1
        else x * fact (x - 1)
    val half_pi = Math.pi / 2.0
    fun doubler y = y + y
    end
    :> MATHLIB 表示，只有结构 MyMathLib 真的提供了签名 MATHLIB 声明的所有东西且类型准确，才能通过类型检查。
隐藏东西：
    把接口从执行分出来可能是构建正确、强健、可重复使用的程序最重要的策略。
    我们通过利用函数已经可以隐藏代码实现的过程了。定义本地私有函数也可以隐藏函数的实现。从工程学的角度，我可以改进代码的实现，而不用担心影响客户的使用，同时，客户做的事情也无法影响我的函数。
    但是，如果您希望有两个顶级函数，其他模块中的代码可以使用它们，并且它们都使用相同的隐藏函数，那么该怎么办呢？可以构建模块“私有的”的函数。在 ML 中，没有 private 这个关键字。所以可以使用签名，但签名里不提到要被隐藏的信息。

68-69. 一个例子
略

70. 签名匹配的规则
如果一个结构不能和分配给他的签名匹配，这个模块就不能通过类型检查。
一个结构 Name 匹配一个签名 BLAH 的前提是：
    对每一个 BLAH 中的变量绑定，Name 必须有一个绑定对应那个类型或者更通用的类型。这个绑定可以是变量绑定、函数绑定或数据类型绑定。
    对 BLAH 中每一个非抽象的的类型绑定，Name 必须有相同的类型绑定。
    对 BLAH 中每一个抽象的的类型绑定，Name 必须有绑定能生成这个类型，可以通过数据类型绑定或同义的类型。
    Name 可以有任何不在签名中的额外的绑定。

71-72. 等价实现
等价实现是另一个很重要的软件开发任务：用一种不会影响客户使用的方式改进/改变库。多亏了 ML 的签名，让我们知道客户会遵守抽象的边界，这对我们而言是很宝贵的。
例子略。

73. 不同的模块定义不同的类型
虽然我们把不同的结构和相同的签名定义在了一起，不代表我们就可以在不同的结构间互相使用绑定。
例如 Rational2.rational 和 Rational1.rational 虽然看起来是一样的，但他们是不同的类型。他们并不是被相同的数据类型绑定所创造的。
此外，我们在模块外的时候，也不应该知道他们看起来是一样的。

74. 类型推断
Java, C, 和 ML 都是静态类型语言，表示每一个绑定都在编译的时候就有了决定好的数据类型。
Racket, Ruby, 和 Python 是动态类型语言，表示绑定的数据类需并不会提前决定，当计算的时候出现了类型错误时才会返回报错。
不像 Java 和 C, ML 是隐式类型，表示程序员几乎不用写下绑定的数据类型。当由于它是静态语言，类型检查就必须更熟练地推断出程序员更可能写的是什么类型注解。原则上，类型推断和类型检查可以是不同的步骤，但实际上，他们经常被合并成类型检查器。需要注意的是，一个正确的类型推断器必须找出一种解决方案，在这种解决方案中所有的类型都应该成立，否则它必须拒绝这个程序。
ML 的设计相当巧妙，因此类型推断可以通过相当直接和优雅的算法来执行。虽然有些程序的推理速度非常慢，但人们在实践中编写的程序永远不会导致这种行为。
ML 类型推断最终与参数多态性交织在一起，当推断器确定一个函数的参数或结果“可能是任何东西”时，结果类型使用 'a 、 'b 等。例如，Java 有泛型，但是没有方法参数/结果类型的推断。

75. ML 类型推断
ML 类型推断的工作方式：
    照顺序确定绑定的类型，使用早期绑定的类型来推断后期绑定的类型。这就是为什么不能在文件中使用稍后的绑定。(当需要时，可以使用相互递归和类型推断来确定所有相互递归绑定的类型。
    对于每个变量或函数的绑定，分析绑定以确定推断其类型所用到的必要事实。
    之后，对于函数参数或结果中的任意无约束类型，使用类型变量（'a）。
    执行值限制——仅变量和值可以具有多态类型，后面讨论。
关于 ML 类型系统的一个令人惊讶的事实是，以这种方式“按顺序进行”永远不会导致我们拒绝能够进行类型检查的程序，也永远不会接受我们不应该接受的程序。因此显式类型注释实际上是可选的，除非使用 #1 这样的特性。( #1 的问题是，它没有提供足够的信息来进行类型推断，以便知道元组/记录应该具有哪些其他字段，而 ML 类型系统要求知道字段的确切数量和所有字段的名称。)

76-77. 关于类型推断的更多例子 / 多态的例子
略

78. 选学: 值限制和其他类型推断的挑战
ML 类型系统是不健全的，这意味着它将接受那些在运行时可能具有错误类型值的程序，例如在预期字符串的地方放置 int 。这个问题是由多态类型和可变引用的组合造成的，修复的方法是类型系统的一个特殊限制，称为值限制。
只有当值绑定的表达式是一个值或者变量的时候，ML 会给值绑定中的变量一个多态的类型，这称为值限制。而比如表达式是函数的时候，会得到警告和一个哑类型。这让哑类型的东西不再有用，而且后面的代码也无法通过类型检查。
这种限制是否足以使类型系统健全，这一点并不明显，但实际上已经足够了。
val r = ref NONE
上例中，r 是个函数。我们可以使用 ref NONE 表达式，但是我们必须使用类型注释给 r 一个非多态类型，比如 int option ref。
值限制有时很繁重，即使有时它不会造成什么问题，都是因为我们不使用可变化的值（mutation）。以下例子并没有使用多态，也沦为了值限制的受害者：
val pairWithOne = List.map (fn x => (x,1))
变通方案之一，使用函数绑定：
fun pairWithOne xs = List.map (fn x => (x,1)) xs
有人可能会想，为什么我们不能只对引用(我们需要它的地方)执行值限制，而不对列表这样的不可变类型执行值限制呢?答案是 ML 类型检查器不能总是知道哪些类型是真正的引用，哪些不是。由于ML的模块系统，类型检查器并不总是知道类型同义词的定义(回想一下，这是一件好事)。为了安全起见，它对所有类型执行了值限制。

79. 相互递归
fun match xs =
    let fun s_need_one xs =
            case xs of
                [] => true
              | 1::xs’ => s_need_two xs’
              | _ => false
        and s_need_two xs =
            case xs of
                [] => false
              | 2::xs’ => s_need_one xs’
              | _ => false
    in
        s_need_one xs
    end
and 关键字是用来定义相互递归的，类型检查器将对所有的函数进行类型检查，允许它们之间相互调用，而不管顺序如何。
相互递归的数据类型绑定的例子：
datatype t1 = Foo of int | Bar of t2
and t2 = Baz of string | Quux of t1
fun no_zeros_or_empty_strings_t1 x =
    case x of
        Foo i => i <> 0
      | Bar y => no_zeros_or_empty_strings_t2 y
and no_zeros_or_empty_strings_t2 x =
    case x of
        Baz s => size s > 0
      | Quux y => no_zeros_or_empty_strings_t1 y
我们可以编写几乎相同的代码，让“稍后”函数将自己传递给“较早”函数的一个版本，该版本将函数作为参数:
fun no_zeros_or_empty_strings_t1(f,x) =
    case x of
        Foo i => i <> 0
      | Bar y => f y
fun no_zeros_or_empty_string_t2 x =
    case x of
        Baz s => size s > 0
      | Quux y => no_zeros_or_empty_strings_t1(no_zeros_or_empty_string_t2,y)
这是函数获取函数的另一个强大的写法。

80. 等价函数
如何判断是否等价：
    函数 f 等价于函数 g (或类似于其他代码片段)，如果它们产生相同的答案，并且具有相同的副作用，不管它们在任何程序中以任何参数调用。
    等价不需要相同的运行时间、相同的内部数据结构的使用、相同的辅助函数等。
更精确的说，当两个函数在相同环境中，被给定相同参数时，满足以下为等价：
    产生相同的结果
    具有相同的(非)终止行为
    以同样的方式改变相同的内存（用户所见到的）
    输入/输出相同
    抛出相同的异常

81. 标准的等价形式
等效性是很微妙的，尤其是当您试图在不知道两个函数可能被调用的所有位置的情况下确定它们是否相等时。
首先，我们可以在函数体中使用或不使用句法糖，得到一个等价的函数。
其次，如果我们一致地更改了局部变量(或函数参数)的所有用法，我们可以更改其名称。但是有一个规则：在选择一个新的变量名时，您不能选择一个函数体已经用来引用其他东西的变量。
第三，我们可以使用或不使用辅助函数。同样，我们必须注意不要因为 f 和 g 可能存在不同的环境而改变变量的含义。
第四，正如我们之前对匿名函数所解释的那样，不必要的函数包装的样子很差，因为有一种更简单的等效方式。如 fun g y = f y 和 val g = f 往往是等价的。但 fun g y = e y 和 val g = e 不总一样（e 指表达式）。
第五，let val p = e1 in e2 end 是 (fn p => e2) e1 的语法糖（p 是 pattern）。

82. 等价和效率
考虑是否等价的时候是否要考虑效率呢？数据结构和算法课程有些研究，但那些定义方式都并不优越，它们对计算机科学家而言都是有价值的观点。
可观察的行为(我们的定义)、渐近复杂性和实际性能都是从事软件工作的人几乎每天都在使用的智能的工具。
